from typing import Iterator, List, Any, Union
from stream import Stream
# Upgrade: Use Science Mode for coefficients to allow negative numbers (Anti-Matter)
# and faster arithmetic.
import science_mode as science
from science_mode import U, S

class ContinuedFraction:
    """
    Represents a number as a stream of continued fraction terms.
    Supports arithmetic operations via the Gosper Engine.
    """
    def __init__(self, stream: Stream):
        self.stream = stream
    
    def __iter__(self):
        return iter(self.stream)

    def _binary_op(self, other: "ContinuedFraction", coeffs: List[Any]) -> "ContinuedFraction":
        """
        Generic binary operation: z = (axy + bx + cy + d) / (exy + fx + gy + h)
        """
        # Import internally to avoid circular imports
        from gosper import gosper_engine
        
        # Create a new stream generated by the Gosper Engine
        # We pass the two input streams and the 8 coefficients
        gen = gosper_engine(self.stream, other.stream, *coeffs)
        return ContinuedFraction(Stream(gen))

    # --- Arithmetic Operations ---
    # Coefficients are chosen to map the operation to the homographic form.
    # Form: (axy + bx + cy + d) / (exy + fx + gy + h)

    def __add__(self, other: "ContinuedFraction") -> "ContinuedFraction":
        # x + y = (xy + x + y + 0) / (0xy + 0x + 0y + 1)
        # Coeffs: 0, 1, 1, 0, 0, 0, 0, 1
        ZERO = U(0)
        ONE = U(1)
        coeffs = [ZERO, ONE, ONE, ZERO, ZERO, ZERO, ZERO, ONE]
        return self._binary_op(other, coeffs)

    def __sub__(self, other: "ContinuedFraction") -> "ContinuedFraction":
        # x - y = (xy + x - y + 0) / (0xy + 0x + 0y + 1)
        # Coeffs: 0, 1, -1, 0, 0, 0, 0, 1
        ZERO = U(0)
        ONE = U(1)
        # FIX: Explicitly construct Negative One using S() 
        # instead of illegal (ZERO - ONE) subtraction.
        NEG_ONE = S(1) 
        coeffs = [ZERO, ONE, NEG_ONE, ZERO, ZERO, ZERO, ZERO, ONE]
        return self._binary_op(other, coeffs)

    def __mul__(self, other: "ContinuedFraction") -> "ContinuedFraction":
        # x * y = (1xy + 0x + 0y + 0) / (0xy + 0x + 0y + 1)
        # Coeffs: 1, 0, 0, 0, 0, 0, 0, 1
        ZERO = U(0)
        ONE = U(1)
        coeffs = [ONE, ZERO, ZERO, ZERO, ZERO, ZERO, ZERO, ONE]
        return self._binary_op(other, coeffs)

    def __truediv__(self, other: "ContinuedFraction") -> "ContinuedFraction":
        # x / y = (0xy + 1x + 0y + 0) / (0xy + 0x + 1y + 0)
        # Coeffs: 0, 1, 0, 0, 0, 0, 1, 0
        ZERO = U(0)
        ONE = U(1)
        coeffs = [ZERO, ONE, ZERO, ZERO, ZERO, ZERO, ONE, ZERO]
        return self._binary_op(other, coeffs)
